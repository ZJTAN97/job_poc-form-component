import React from "react";
import { FieldValues, Path, UseFormReturn } from "react-hook-form";
import { ReferenceType } from "../../../../../../model/common/Reference";
import { SourceType } from "../../../../../../model/common/Source";

/**
 * Retrieve the location of the reference in the form value provided based on the field provided
 * @param {T} formValue form value provided
 * @param { Path<T> } field  Keys within the form generated by React Hook form, specifies which field's references to locate
 * @param { number | undefined } arrayId if selected field is array, have to specify its array Id
 * @returns {stringText, filteredReference}
 */
export const useExistingReference = <T extends FieldValues>({
  formValue,
  field,
  arrayId,
}: {
  formValue: T;
  field: Path<T>;
  arrayId?: number;
}) => {
  const collatedReferences: ReferenceType[] = [];

  // 1. Handles Root References
  collatedReferences.push(...formValue.references);
  const { references, ...remainingFields } = formValue;

  for (let value of Object.values(remainingFields)) {
    if (typeof value === "object") {
      if (!Array.isArray(value)) {
        // 2. Handles Single Object References
        collatedReferences.push(...value.references);
      } else if (Array.isArray(value) && typeof value[0] === "object") {
        // 3. Handles Array Object References
        value.map((obj) => collatedReferences.push(...obj.references));
      }
    }
  }

  let filteredReference: ReferenceType[] = [];
  let stringText = "";

  if (arrayId !== undefined) {
    const filteredByArray = collatedReferences.filter(
      (ref) => ref.field === field,
    );
    filteredReference = filteredByArray.filter((_, id) => id === arrayId);
  } else {
    filteredReference = collatedReferences.filter((ref) => ref.field === field);
  }

  if (filteredReference.length === 1) {
    const numOfSource = filteredReference[0].sources.length;
    const firstSource = filteredReference[0].sources[0];

    if (numOfSource === 1) {
      stringText = `${
        firstSource.referenceType
      }\n${firstSource.dateObtained.slice(0, 10)}`;
    } else if (numOfSource > 1) {
      stringText = `${
        firstSource.referenceType
      }\n${firstSource.dateObtained.slice(0, 10)} + ${numOfSource - 1} more`;
    }
  }

  return {
    stringText: stringText,
    filteredReference: filteredReference[0],
  };
};

/**
 * Updates the respective Reference values in the Form based on provided field
 * @param {UseFormReturn<any, any>} formMethods React Hook Form Methods from useForm Hooks
 * @param { Path<T> } field  Keys within the form generated by React Hook form, specifies which field's references to update
 * @param { number | undefined } arrayId if selected field is array, have to specify its array Id
 * @param { SourceType } source Source Value provided
 */
export const useUpdateReferences = <T extends FieldValues>({
  formMethods,
  source,
}: {
  formMethods: UseFormReturn<any, any>;
  source: SourceType;
}) => {
  const updateReference = ({
    field,
    arrayId,
    sourceId,
  }: {
    field: Path<T>;
    arrayId?: number;
    sourceId?: number;
  }) => {
    const existingReference = useExistingReference({
      formValue: formMethods.getValues(),
      field,
      arrayId,
    }).filteredReference;

    const isObject = field === "rank" || field === "position";
    const isArrayObject =
      (field === "issuedBy" || field === "name") && arrayId !== undefined;
    const isArrayString =
      field === "skills" && existingReference && arrayId !== undefined;

    const updateExistingSources = () => {
      const isAddSource =
        source.referenceType !== undefined && sourceId === undefined;
      const isUpdateSource =
        source.referenceType !== undefined && sourceId !== undefined;
      const isDeleteSource =
        source.referenceType === undefined && sourceId !== undefined;

      if (isAddSource) {
        // add new
        existingReference.sources.push(source);
      } else if (isUpdateSource) {
        // update
        existingReference.sources[sourceId] = source;
      } else if (isDeleteSource) {
        // delete
        existingReference.sources.splice(sourceId, 1);
      }
    };

    // Handle Object Type
    if (isObject) {
      if (existingReference) {
        const referenceIndexToReplace = formMethods
          .getValues()
          .appointment.references.indexOf(existingReference);
        updateExistingSources();
        if (existingReference.sources.length === 0) {
          formMethods
            .getValues()
            .appointment.references.splice(referenceIndexToReplace, 1);
        } else {
          formMethods.getValues().appointment.references[
            referenceIndexToReplace
          ] = existingReference;
        }
      } else {
        formMethods.setValue("appointment.references", [
          ...formMethods.getValues().appointment.references,
          {
            field,
            content: "",
            sources: [source],
          },
        ]);
      }
    }
    // Handle Array String Type
    // Note that for Array String Types,
    // empty sources references are created/removed automatically
    // Refer to StringArrayInput.tsx for implementation
    else if (isArrayString) {
      const referenceIndexToReplace = formMethods
        .getValues()
        .references.indexOf(existingReference);
      updateExistingSources();
      formMethods.getValues().references[referenceIndexToReplace] =
        existingReference;
    }
    // Handle Array Object Type
    else if (isArrayObject) {
      const selectedObject = formMethods.getValues().certsToField[arrayId];
      if (existingReference) {
        const indexToReplace =
          selectedObject.references.indexOf(existingReference);
        updateExistingSources();
        selectedObject.references[indexToReplace] = existingReference;
      } else {
        selectedObject.references.push({
          field,
          content: "",
          sources: [source],
        });
      }
      let existingArrayObjects = [...formMethods.getValues().certsToField];
      existingArrayObjects[arrayId] = selectedObject;
      formMethods.setValue("certsToField", existingArrayObjects);
    }
    // Handle String Type
    else {
      if (existingReference) {
        const indexToReplace = formMethods
          .getValues()
          .references.indexOf(existingReference);
        updateExistingSources();
        formMethods.getValues().references[indexToReplace] = existingReference;
      } else {
        formMethods.setValue("references", [
          ...formMethods.getValues().references,
          {
            field,
            content: "",
            sources: [source],
          },
        ]);
      }
    }
  };

  return {
    updateReference,
  };
};
